package com.easterne.javase.array;

/**
 * Array：
 *      1、Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object
 *
 *      2、数组实际上是一个容器，可以同时容纳多个元素（数组是一个数据的集合）
 *
 *      3、数组当中可以存储”基本数据类型“，也可以存储”引用数据类型“
 *
 *      4、数组是引用数据类型，所以数组对象是在堆内存中（数组是存储在堆当中的）
 *
 *      5、数组中如果存储的是”java对象“的话，实际上存储的是对象的”引用（内存地址）“，数组
 *      中不能直接存储Java对象
 *
 *      6、数组一旦创建，长度就不能变了（数组长度不可变）
 *
 *      7、数组分类：一维数组、二维数组、三维数组……
 *
 *      8、所有的数组对象都有length属性（Java自带），用来获取数组长度
 *
 *      9、Java中的数组要求数组中元素类型统一。比如：int类型数组只能存储int类型数据
 *
 *      10、数组在数据存储方面，元素内存地址是连续的
 *
 *      11、所有的数组都是以第一个元素的地址作为整个数组对象的内存地址的
 *
 *      12、数组这种数据结构的优点和缺点：
 *          优点：查询/查找/检索某个下标上的元素时效率极高。
 *              为什么检索效率高？
 *                  - 每一个元素的内存地址在空间存储上是连续的
 *                  - 每一个元素类型相同，所以占用空间大小一样
 *                  - 数组以第一个元素的内存地址为数组地址，所以可以通过算式，给出下标便可
 *                    很快地计算出对应元素的内存地址。直接通过内存地址定位，所以数组的检索
 *                    效率极高
 *
 *          缺点：
 *              - 由于为了保证数组中每个元素的内存地址连续，所以数组在进行增删操作时，效率
 *                较低：因为增删元素涉及到后面元素统一向前或向后移动的操作
 *              - 数组不能存储大数据量：因为很难在内存空间上找到一块特别大的连续的内存空间
 *
 *      14、怎么声明/定义一个一维数组？
 *          语法格式：
 *              int[] array1;
 *              double[] array2;
 *              ……
 *              Object[] array3;
 *
 *      15、怎么初始化一个一维数组呢？
 *          包括两种方式：静态初始化、动态初始化
 *          - 静态初始化语法：
 *              int[] array = {100, 2100, 300, 55};
 *          - 动态初始化语法：
 *              int[] array = new int[5];   // 这里的5表示数组的元素个数
 *                                          // 每个元素默认为0
 *              String[] names = new String[6];     // 6表示数组能保存的String元素个数
 *                                                  // 每个元素默认为null
 *
 *      16、数组下标越界的经典报错：ArrayIndexOutOfBoundsException
 */
public class ArrayTest {

    public static void main(String[] args) {
        int[] a1 = {1, 100, 20, 34};

        // 所有数组对象都有length属性
        System.out.println("a1长度：" + a1.length);

        // 下标访问数组元素
        System.out.println("第一个元素a[0] = " + a1[0]);
        System.out.println("最后一个元素a[" + (a1.length - 1) + "] = "
                            + a1[a1.length - 1]);
    }

}
